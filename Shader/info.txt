Typical shader structure:

#version version_number
in type in_variable_name;
in type in_variable_name;

out type out_variable_name;

uniform type uniform_name;

void main() {
    //process inputs and do graphics stuff
    ...
    //output processed stuff to output variable
    out_variable_name = stuff_processed
}


To find out the number of 4-component VAs available:
int nrAttributes;
glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &nrAttributes);
cout << "Maximum no. of vertex attributes supported: " << nrAttributes << endl;


Vectors
- n component container for basic types (1<=n<=4)
- vecn, bvecn, ivecn, etc. 
- b = boolean, i = int, u = unsigned int, d = double


Swizzling:
- vec2 someVec;
- vec4 differentVec = someVec.xyxx;
- vec3 anotherVec = differentVec.zyw;
- vec4 otherVec = someVec.xxxx + anotherVec.yxzy;
- vec2 vect = vec2(0.5, 0.7);
- vec4 result = vec4(vect, 0.0, 0.0);
- vec4 otherResult = vec4(result.xyz, 1.0);


Vertex shaders:
- each input variable -> vertex attribute
- receives input straight from vertex data

To define how the vertex data is organized, we specify the input variables 
with location metadata so we can configure the vertex attributes on the CPU. 
We've seen this as layout (location = 0). 
The vertex shader thus requires an extra layout specification for its inputs 
so we can link it with the vertex data.


Fragment shader: requires a vec4 color output variable.
